// Code generated by ogen, DO NOT EDIT.

package marzban

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode encodes ActivateAllDisabledUsersOKApplicationJSON as json.
func (s ActivateAllDisabledUsersOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes ActivateAllDisabledUsersOKApplicationJSON from json.
func (s *ActivateAllDisabledUsersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivateAllDisabledUsersOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ActivateAllDisabledUsersOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActivateAllDisabledUsersOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivateAllDisabledUsersOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Admin) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Admin) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("is_sudo")
		e.Bool(s.IsSudo)
	}
	{
		if s.TelegramID.Set {
			e.FieldStart("telegram_id")
			s.TelegramID.Encode(e)
		}
	}
	{
		if s.DiscordWebhook.Set {
			e.FieldStart("discord_webhook")
			s.DiscordWebhook.Encode(e)
		}
	}
	{
		if s.UsersUsage.Set {
			e.FieldStart("users_usage")
			s.UsersUsage.Encode(e)
		}
	}
}

var jsonFieldsNameOfAdmin = [5]string{
	0: "username",
	1: "is_sudo",
	2: "telegram_id",
	3: "discord_webhook",
	4: "users_usage",
}

// Decode decodes Admin from json.
func (s *Admin) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Admin to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "is_sudo":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsSudo = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_sudo\"")
			}
		case "telegram_id":
			if err := func() error {
				s.TelegramID.Reset()
				if err := s.TelegramID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegram_id\"")
			}
		case "discord_webhook":
			if err := func() error {
				s.DiscordWebhook.Reset()
				if err := s.DiscordWebhook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discord_webhook\"")
			}
		case "users_usage":
			if err := func() error {
				s.UsersUsage.Reset()
				if err := s.UsersUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users_usage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Admin")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAdmin) {
					name = jsonFieldsNameOfAdmin[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Admin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Admin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AdminCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AdminCreate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("is_sudo")
		e.Bool(s.IsSudo)
	}
	{
		if s.TelegramID.Set {
			e.FieldStart("telegram_id")
			s.TelegramID.Encode(e)
		}
	}
	{
		if s.DiscordWebhook.Set {
			e.FieldStart("discord_webhook")
			s.DiscordWebhook.Encode(e)
		}
	}
	{
		if s.UsersUsage.Set {
			e.FieldStart("users_usage")
			s.UsersUsage.Encode(e)
		}
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfAdminCreate = [6]string{
	0: "username",
	1: "is_sudo",
	2: "telegram_id",
	3: "discord_webhook",
	4: "users_usage",
	5: "password",
}

// Decode decodes AdminCreate from json.
func (s *AdminCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdminCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "is_sudo":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsSudo = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_sudo\"")
			}
		case "telegram_id":
			if err := func() error {
				s.TelegramID.Reset()
				if err := s.TelegramID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegram_id\"")
			}
		case "discord_webhook":
			if err := func() error {
				s.DiscordWebhook.Reset()
				if err := s.DiscordWebhook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discord_webhook\"")
			}
		case "users_usage":
			if err := func() error {
				s.UsersUsage.Reset()
				if err := s.UsersUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users_usage\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AdminCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAdminCreate) {
					name = jsonFieldsNameOfAdminCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdminCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdminCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AdminModify) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AdminModify) encodeFields(e *jx.Encoder) {
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		e.FieldStart("is_sudo")
		e.Bool(s.IsSudo)
	}
	{
		if s.TelegramID.Set {
			e.FieldStart("telegram_id")
			s.TelegramID.Encode(e)
		}
	}
	{
		if s.DiscordWebhook.Set {
			e.FieldStart("discord_webhook")
			s.DiscordWebhook.Encode(e)
		}
	}
}

var jsonFieldsNameOfAdminModify = [4]string{
	0: "password",
	1: "is_sudo",
	2: "telegram_id",
	3: "discord_webhook",
}

// Decode decodes AdminModify from json.
func (s *AdminModify) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdminModify to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "is_sudo":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsSudo = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_sudo\"")
			}
		case "telegram_id":
			if err := func() error {
				s.TelegramID.Reset()
				if err := s.TelegramID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegram_id\"")
			}
		case "discord_webhook":
			if err := func() error {
				s.DiscordWebhook.Reset()
				if err := s.DiscordWebhook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discord_webhook\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AdminModify")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAdminModify) {
					name = jsonFieldsNameOfAdminModify[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdminModify) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdminModify) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Conflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Conflict) encodeFields(e *jx.Encoder) {
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
}

var jsonFieldsNameOfConflict = [1]string{
	0: "detail",
}

// Decode decodes Conflict from json.
func (s *Conflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Conflict to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Conflict")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Conflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Conflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CoreStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CoreStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("started")
		e.Bool(s.Started)
	}
	{
		e.FieldStart("logs_websocket")
		e.Str(s.LogsWebsocket)
	}
}

var jsonFieldsNameOfCoreStats = [3]string{
	0: "version",
	1: "started",
	2: "logs_websocket",
}

// Decode decodes CoreStats from json.
func (s *CoreStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CoreStats to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "started":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Started = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started\"")
			}
		case "logs_websocket":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.LogsWebsocket = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logs_websocket\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CoreStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCoreStats) {
					name = jsonFieldsNameOfCoreStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CoreStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CoreStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteExpiredUsersOKApplicationJSON as json.
func (s DeleteExpiredUsersOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes DeleteExpiredUsersOKApplicationJSON from json.
func (s *DeleteExpiredUsersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteExpiredUsersOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteExpiredUsersOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteExpiredUsersOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteExpiredUsersOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisableAllActiveUsersOKApplicationJSON as json.
func (s DisableAllActiveUsersOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes DisableAllActiveUsersOKApplicationJSON from json.
func (s *DisableAllActiveUsersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableAllActiveUsersOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DisableAllActiveUsersOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DisableAllActiveUsersOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableAllActiveUsersOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Forbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Forbidden) encodeFields(e *jx.Encoder) {
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
}

var jsonFieldsNameOfForbidden = [1]string{
	0: "detail",
}

// Decode decodes Forbidden from json.
func (s *Forbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Forbidden to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Forbidden")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Forbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Forbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAdminUsageOKApplicationJSON as json.
func (s GetAdminUsageOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := int(s)

	e.Int(unwrapped)
}

// Decode decodes GetAdminUsageOKApplicationJSON from json.
func (s *GetAdminUsageOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAdminUsageOKApplicationJSON to nil")
	}
	var unwrapped int
	if err := func() error {
		v, err := d.Int()
		unwrapped = int(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetAdminUsageOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAdminUsageOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAdminUsageOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAdminsOKApplicationJSON as json.
func (s GetAdminsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Admin(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetAdminsOKApplicationJSON from json.
func (s *GetAdminsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAdminsOKApplicationJSON to nil")
	}
	var unwrapped []Admin
	if err := func() error {
		unwrapped = make([]Admin, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Admin
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetAdminsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAdminsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAdminsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetCoreConfigOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetCoreConfigOK) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetCoreConfigOK = [0]string{}

// Decode decodes GetCoreConfigOK from json.
func (s *GetCoreConfigOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCoreConfigOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetCoreConfigOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCoreConfigOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCoreConfigOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetExpiredUsersOKApplicationJSON as json.
func (s GetExpiredUsersOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes GetExpiredUsersOKApplicationJSON from json.
func (s *GetExpiredUsersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetExpiredUsersOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetExpiredUsersOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetExpiredUsersOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetExpiredUsersOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetHostsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetHostsOK) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes GetHostsOK from json.
func (s *GetHostsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHostsOK to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []ProxyHost
		if err := func() error {
			elem = make([]ProxyHost, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem ProxyHost
				if err := elemElem.Decode(d); err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetHostsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetHostsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHostsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetInboundsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetInboundsOK) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes GetInboundsOK from json.
func (s *GetInboundsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInboundsOK to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []ProxyInbound
		if err := func() error {
			elem = make([]ProxyInbound, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem ProxyInbound
				if err := elemElem.Decode(d); err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInboundsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetInboundsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInboundsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNodesOKApplicationJSON as json.
func (s GetNodesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []NodeResponse(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetNodesOKApplicationJSON from json.
func (s *GetNodesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesOKApplicationJSON to nil")
	}
	var unwrapped []NodeResponse
	if err := func() error {
		unwrapped = make([]NodeResponse, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem NodeResponse
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNodesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetNodesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserTemplatesOKApplicationJSON as json.
func (s GetUserTemplatesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []UserTemplateResponse(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetUserTemplatesOKApplicationJSON from json.
func (s *GetUserTemplatesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserTemplatesOKApplicationJSON to nil")
	}
	var unwrapped []UserTemplateResponse
	if err := func() error {
		unwrapped = make([]UserTemplateResponse, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem UserTemplateResponse
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUserTemplatesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserTemplatesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserTemplatesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTTPException) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTTPException) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("detail")
		e.Str(s.Detail)
	}
}

var jsonFieldsNameOfHTTPException = [1]string{
	0: "detail",
}

// Decode decodes HTTPException from json.
func (s *HTTPException) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTTPException to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "detail":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Detail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTTPException")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHTTPException) {
					name = jsonFieldsNameOfHTTPException[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTTPException) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTTPException) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTTPValidationError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTTPValidationError) encodeFields(e *jx.Encoder) {
	{
		if s.Detail != nil {
			e.FieldStart("detail")
			e.ArrStart()
			for _, elem := range s.Detail {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHTTPValidationError = [1]string{
	0: "detail",
}

// Decode decodes HTTPValidationError from json.
func (s *HTTPValidationError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTTPValidationError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "detail":
			if err := func() error {
				s.Detail = make([]ValidationError, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValidationError
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Detail = append(s.Detail, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTTPValidationError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTTPValidationError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTTPValidationError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModifyCoreConfigOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModifyCoreConfigOK) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfModifyCoreConfigOK = [0]string{}

// Decode decodes ModifyCoreConfigOK from json.
func (s *ModifyCoreConfigOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModifyCoreConfigOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ModifyCoreConfigOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModifyCoreConfigOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModifyCoreConfigOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModifyCoreConfigReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModifyCoreConfigReq) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfModifyCoreConfigReq = [0]string{}

// Decode decodes ModifyCoreConfigReq from json.
func (s *ModifyCoreConfigReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModifyCoreConfigReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ModifyCoreConfigReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModifyCoreConfigReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModifyCoreConfigReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ModifyHostsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ModifyHostsOK) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes ModifyHostsOK from json.
func (s *ModifyHostsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModifyHostsOK to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []ProxyHost
		if err := func() error {
			elem = make([]ProxyHost, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem ProxyHost
				if err := elemElem.Decode(d); err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModifyHostsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ModifyHostsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModifyHostsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ModifyHostsReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ModifyHostsReq) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes ModifyHostsReq from json.
func (s *ModifyHostsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModifyHostsReq to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []ProxyHost
		if err := func() error {
			elem = make([]ProxyHost, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem ProxyHost
				if err := elemElem.Decode(d); err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModifyHostsReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ModifyHostsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModifyHostsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NextPlanModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NextPlanModel) encodeFields(e *jx.Encoder) {
	{
		if s.DataLimit.Set {
			e.FieldStart("data_limit")
			s.DataLimit.Encode(e)
		}
	}
	{
		if s.Expire.Set {
			e.FieldStart("expire")
			s.Expire.Encode(e)
		}
	}
	{
		if s.AddRemainingTraffic.Set {
			e.FieldStart("add_remaining_traffic")
			s.AddRemainingTraffic.Encode(e)
		}
	}
	{
		if s.FireOnEither.Set {
			e.FieldStart("fire_on_either")
			s.FireOnEither.Encode(e)
		}
	}
}

var jsonFieldsNameOfNextPlanModel = [4]string{
	0: "data_limit",
	1: "expire",
	2: "add_remaining_traffic",
	3: "fire_on_either",
}

// Decode decodes NextPlanModel from json.
func (s *NextPlanModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NextPlanModel to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data_limit":
			if err := func() error {
				s.DataLimit.Reset()
				if err := s.DataLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_limit\"")
			}
		case "expire":
			if err := func() error {
				s.Expire.Reset()
				if err := s.Expire.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expire\"")
			}
		case "add_remaining_traffic":
			if err := func() error {
				s.AddRemainingTraffic.Reset()
				if err := s.AddRemainingTraffic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"add_remaining_traffic\"")
			}
		case "fire_on_either":
			if err := func() error {
				s.FireOnEither.Reset()
				if err := s.FireOnEither.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fire_on_either\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NextPlanModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NextPlanModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NextPlanModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o NilInt) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *NilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o NilString) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *NilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodeCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodeCreate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.APIPort.Set {
			e.FieldStart("api_port")
			s.APIPort.Encode(e)
		}
	}
	{
		if s.UsageCoefficient.Set {
			e.FieldStart("usage_coefficient")
			s.UsageCoefficient.Encode(e)
		}
	}
	{
		if s.AddAsNewHost.Set {
			e.FieldStart("add_as_new_host")
			s.AddAsNewHost.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodeCreate = [6]string{
	0: "name",
	1: "address",
	2: "port",
	3: "api_port",
	4: "usage_coefficient",
	5: "add_as_new_host",
}

// Decode decodes NodeCreate from json.
func (s *NodeCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeCreate to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "api_port":
			if err := func() error {
				s.APIPort.Reset()
				if err := s.APIPort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_port\"")
			}
		case "usage_coefficient":
			if err := func() error {
				s.UsageCoefficient.Reset()
				if err := s.UsageCoefficient.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage_coefficient\"")
			}
		case "add_as_new_host":
			if err := func() error {
				s.AddAsNewHost.Reset()
				if err := s.AddAsNewHost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"add_as_new_host\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodeCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNodeCreate) {
					name = jsonFieldsNameOfNodeCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodeCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodeModify) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodeModify) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Address.Set {
			e.FieldStart("address")
			s.Address.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.APIPort.Set {
			e.FieldStart("api_port")
			s.APIPort.Encode(e)
		}
	}
	{
		if s.UsageCoefficient.Set {
			e.FieldStart("usage_coefficient")
			s.UsageCoefficient.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodeModify = [6]string{
	0: "name",
	1: "address",
	2: "port",
	3: "api_port",
	4: "usage_coefficient",
	5: "status",
}

// Decode decodes NodeModify from json.
func (s *NodeModify) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeModify to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			if err := func() error {
				s.Address.Reset()
				if err := s.Address.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "api_port":
			if err := func() error {
				s.APIPort.Reset()
				if err := s.APIPort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_port\"")
			}
		case "usage_coefficient":
			if err := func() error {
				s.UsageCoefficient.Reset()
				if err := s.UsageCoefficient.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage_coefficient\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodeModify")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodeModify) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeModify) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodeResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodeResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.APIPort.Set {
			e.FieldStart("api_port")
			s.APIPort.Encode(e)
		}
	}
	{
		if s.UsageCoefficient.Set {
			e.FieldStart("usage_coefficient")
			s.UsageCoefficient.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
	{
		if s.XrayVersion.Set {
			e.FieldStart("xray_version")
			s.XrayVersion.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodeResponse = [9]string{
	0: "name",
	1: "address",
	2: "port",
	3: "api_port",
	4: "usage_coefficient",
	5: "id",
	6: "xray_version",
	7: "status",
	8: "message",
}

// Decode decodes NodeResponse from json.
func (s *NodeResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeResponse to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "api_port":
			if err := func() error {
				s.APIPort.Reset()
				if err := s.APIPort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_port\"")
			}
		case "usage_coefficient":
			if err := func() error {
				s.UsageCoefficient.Reset()
				if err := s.UsageCoefficient.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage_coefficient\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "xray_version":
			if err := func() error {
				s.XrayVersion.Reset()
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xray_version\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodeResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10100011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNodeResponse) {
					name = jsonFieldsNameOfNodeResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodeResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodeSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodeSettings) encodeFields(e *jx.Encoder) {
	{
		if s.MinNodeVersion.Set {
			e.FieldStart("min_node_version")
			s.MinNodeVersion.Encode(e)
		}
	}
	{
		e.FieldStart("certificate")
		e.Str(s.Certificate)
	}
}

var jsonFieldsNameOfNodeSettings = [2]string{
	0: "min_node_version",
	1: "certificate",
}

// Decode decodes NodeSettings from json.
func (s *NodeSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeSettings to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "min_node_version":
			if err := func() error {
				s.MinNodeVersion.Reset()
				if err := s.MinNodeVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_node_version\"")
			}
		case "certificate":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Certificate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodeSettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNodeSettings) {
					name = jsonFieldsNameOfNodeSettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodeSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeStatus as json.
func (s NodeStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NodeStatus from json.
func (s *NodeStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NodeStatus(v) {
	case NodeStatusConnected:
		*s = NodeStatusConnected
	case NodeStatusConnecting:
		*s = NodeStatusConnecting
	case NodeStatusError:
		*s = NodeStatusError
	case NodeStatusDisabled:
		*s = NodeStatusDisabled
	default:
		*s = NodeStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NodeStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodeUsageResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodeUsageResponse) encodeFields(e *jx.Encoder) {
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
	{
		e.FieldStart("node_name")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("uplink")
		e.Int(s.Uplink)
	}
	{
		e.FieldStart("downlink")
		e.Int(s.Downlink)
	}
}

var jsonFieldsNameOfNodeUsageResponse = [4]string{
	0: "node_id",
	1: "node_name",
	2: "uplink",
	3: "downlink",
}

// Decode decodes NodeUsageResponse from json.
func (s *NodeUsageResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeUsageResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "node_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_name\"")
			}
		case "uplink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Uplink = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uplink\"")
			}
		case "downlink":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Downlink = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downlink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodeUsageResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNodeUsageResponse) {
					name = jsonFieldsNameOfNodeUsageResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodeUsageResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeUsageResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesUsageResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesUsageResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("usages")
		e.ArrStart()
		for _, elem := range s.Usages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfNodesUsageResponse = [1]string{
	0: "usages",
}

// Decode decodes NodesUsageResponse from json.
func (s *NodesUsageResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesUsageResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "usages":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Usages = make([]NodeUsageResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodeUsageResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Usages = append(s.Usages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesUsageResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNodesUsageResponse) {
					name = jsonFieldsNameOfNodesUsageResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesUsageResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesUsageResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotFound) encodeFields(e *jx.Encoder) {
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
}

var jsonFieldsNameOfNotFound = [1]string{
	0: "detail",
}

// Decode decodes NotFound from json.
func (s *NotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotFound to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotFound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Admin as json.
func (o OptAdmin) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Admin from json.
func (o *OptAdmin) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAdmin to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAdmin) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAdmin) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NextPlanModel as json.
func (o OptNextPlanModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NextPlanModel from json.
func (o *OptNextPlanModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNextPlanModel to nil")
	}
	if d.Next() == jx.Null {
		d.Null()
		o.Set = false
		return nil
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNextPlanModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNextPlanModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptNilBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptNilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBool to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v bool
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptNilDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptNilDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilDateTime to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float64 as json.
func (o OptNilFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptNilFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFloat64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float64
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeStatus as json.
func (o OptNodeStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NodeStatus from json.
func (o *OptNodeStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNodeStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNodeStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNodeStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProxyHostALPN as json.
func (o OptProxyHostALPN) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProxyHostALPN from json.
func (o *OptProxyHostALPN) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProxyHostALPN to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProxyHostALPN) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProxyHostALPN) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProxyHostFingerprint as json.
func (o OptProxyHostFingerprint) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProxyHostFingerprint from json.
func (o *OptProxyHostFingerprint) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProxyHostFingerprint to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProxyHostFingerprint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProxyHostFingerprint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProxyHostSecurity as json.
func (o OptProxyHostSecurity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProxyHostSecurity from json.
func (o *OptProxyHostSecurity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProxyHostSecurity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProxyHostSecurity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProxyHostSecurity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserCreateInbounds as json.
func (o OptUserCreateInbounds) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserCreateInbounds from json.
func (o *OptUserCreateInbounds) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserCreateInbounds to nil")
	}
	o.Set = true
	o.Value = make(UserCreateInbounds)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserCreateInbounds) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserCreateInbounds) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserCreateProxies as json.
func (o OptUserCreateProxies) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserCreateProxies from json.
func (o *OptUserCreateProxies) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserCreateProxies to nil")
	}
	o.Set = true
	o.Value = make(UserCreateProxies)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserCreateProxies) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserCreateProxies) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserDataLimitResetStrategy as json.
func (o OptUserDataLimitResetStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserDataLimitResetStrategy from json.
func (o *OptUserDataLimitResetStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserDataLimitResetStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserDataLimitResetStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserDataLimitResetStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserModifyInbounds as json.
func (o OptUserModifyInbounds) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserModifyInbounds from json.
func (o *OptUserModifyInbounds) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserModifyInbounds to nil")
	}
	o.Set = true
	o.Value = make(UserModifyInbounds)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserModifyInbounds) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserModifyInbounds) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserModifyProxies as json.
func (o OptUserModifyProxies) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserModifyProxies from json.
func (o *OptUserModifyProxies) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserModifyProxies to nil")
	}
	o.Set = true
	o.Value = make(UserModifyProxies)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserModifyProxies) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserModifyProxies) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserResponseExcludedInbounds as json.
func (o OptUserResponseExcludedInbounds) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserResponseExcludedInbounds from json.
func (o *OptUserResponseExcludedInbounds) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserResponseExcludedInbounds to nil")
	}
	o.Set = true
	o.Value = make(UserResponseExcludedInbounds)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserResponseExcludedInbounds) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserResponseExcludedInbounds) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserResponseInbounds as json.
func (o OptUserResponseInbounds) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserResponseInbounds from json.
func (o *OptUserResponseInbounds) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserResponseInbounds to nil")
	}
	o.Set = true
	o.Value = make(UserResponseInbounds)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserResponseInbounds) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserResponseInbounds) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserStatus as json.
func (o OptUserStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserStatus from json.
func (o *OptUserStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserStatusCreate as json.
func (o OptUserStatusCreate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserStatusCreate from json.
func (o *OptUserStatusCreate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserStatusCreate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserStatusCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserStatusCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserStatusModify as json.
func (o OptUserStatusModify) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserStatusModify from json.
func (o *OptUserStatusModify) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserStatusModify to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserStatusModify) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserStatusModify) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserTemplateCreateInbounds as json.
func (o OptUserTemplateCreateInbounds) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserTemplateCreateInbounds from json.
func (o *OptUserTemplateCreateInbounds) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserTemplateCreateInbounds to nil")
	}
	o.Set = true
	o.Value = make(UserTemplateCreateInbounds)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserTemplateCreateInbounds) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserTemplateCreateInbounds) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserTemplateModifyInbounds as json.
func (o OptUserTemplateModifyInbounds) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserTemplateModifyInbounds from json.
func (o *OptUserTemplateModifyInbounds) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserTemplateModifyInbounds to nil")
	}
	o.Set = true
	o.Value = make(UserTemplateModifyInbounds)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserTemplateModifyInbounds) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserTemplateModifyInbounds) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserTemplateResponseInbounds as json.
func (o OptUserTemplateResponseInbounds) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserTemplateResponseInbounds from json.
func (o *OptUserTemplateResponseInbounds) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserTemplateResponseInbounds to nil")
	}
	o.Set = true
	o.Value = make(UserTemplateResponseInbounds)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserTemplateResponseInbounds) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserTemplateResponseInbounds) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProxyHost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProxyHost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.Sni.Set {
			e.FieldStart("sni")
			s.Sni.Encode(e)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Security.Set {
			e.FieldStart("security")
			s.Security.Encode(e)
		}
	}
	{
		if s.Alpn.Set {
			e.FieldStart("alpn")
			s.Alpn.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			e.FieldStart("fingerprint")
			s.Fingerprint.Encode(e)
		}
	}
	{
		if s.Allowinsecure.Set {
			e.FieldStart("allowinsecure")
			s.Allowinsecure.Encode(e)
		}
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("is_disabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.MuxEnable.Set {
			e.FieldStart("mux_enable")
			s.MuxEnable.Encode(e)
		}
	}
	{
		if s.FragmentSetting.Set {
			e.FieldStart("fragment_setting")
			s.FragmentSetting.Encode(e)
		}
	}
	{
		if s.NoiseSetting.Set {
			e.FieldStart("noise_setting")
			s.NoiseSetting.Encode(e)
		}
	}
	{
		if s.RandomUserAgent.Set {
			e.FieldStart("random_user_agent")
			s.RandomUserAgent.Encode(e)
		}
	}
	{
		if s.UseSniAsHost.Set {
			e.FieldStart("use_sni_as_host")
			s.UseSniAsHost.Encode(e)
		}
	}
}

var jsonFieldsNameOfProxyHost = [16]string{
	0:  "remark",
	1:  "address",
	2:  "port",
	3:  "sni",
	4:  "host",
	5:  "path",
	6:  "security",
	7:  "alpn",
	8:  "fingerprint",
	9:  "allowinsecure",
	10: "is_disabled",
	11: "mux_enable",
	12: "fragment_setting",
	13: "noise_setting",
	14: "random_user_agent",
	15: "use_sni_as_host",
}

// Decode decodes ProxyHost from json.
func (s *ProxyHost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProxyHost to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "remark":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "sni":
			if err := func() error {
				s.Sni.Reset()
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "security":
			if err := func() error {
				s.Security.Reset()
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "alpn":
			if err := func() error {
				s.Alpn.Reset()
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "allowinsecure":
			if err := func() error {
				s.Allowinsecure.Reset()
				if err := s.Allowinsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowinsecure\"")
			}
		case "is_disabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_disabled\"")
			}
		case "mux_enable":
			if err := func() error {
				s.MuxEnable.Reset()
				if err := s.MuxEnable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mux_enable\"")
			}
		case "fragment_setting":
			if err := func() error {
				s.FragmentSetting.Reset()
				if err := s.FragmentSetting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fragment_setting\"")
			}
		case "noise_setting":
			if err := func() error {
				s.NoiseSetting.Reset()
				if err := s.NoiseSetting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"noise_setting\"")
			}
		case "random_user_agent":
			if err := func() error {
				s.RandomUserAgent.Reset()
				if err := s.RandomUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"random_user_agent\"")
			}
		case "use_sni_as_host":
			if err := func() error {
				s.UseSniAsHost.Reset()
				if err := s.UseSniAsHost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_sni_as_host\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProxyHost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProxyHost) {
					name = jsonFieldsNameOfProxyHost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProxyHost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProxyHost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProxyHostALPN as json.
func (s ProxyHostALPN) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProxyHostALPN from json.
func (s *ProxyHostALPN) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProxyHostALPN to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProxyHostALPN(v) {
	case ProxyHostALPNEmpty:
		*s = ProxyHostALPNEmpty
	case ProxyHostALPNH3:
		*s = ProxyHostALPNH3
	case ProxyHostALPNH2:
		*s = ProxyHostALPNH2
	case ProxyHostALPNHTTP11:
		*s = ProxyHostALPNHTTP11
	case ProxyHostALPNH3H2HTTP11:
		*s = ProxyHostALPNH3H2HTTP11
	case ProxyHostALPNH3H2:
		*s = ProxyHostALPNH3H2
	case ProxyHostALPNH2HTTP11:
		*s = ProxyHostALPNH2HTTP11
	default:
		*s = ProxyHostALPN(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProxyHostALPN) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProxyHostALPN) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProxyHostFingerprint as json.
func (s ProxyHostFingerprint) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProxyHostFingerprint from json.
func (s *ProxyHostFingerprint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProxyHostFingerprint to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProxyHostFingerprint(v) {
	case ProxyHostFingerprintEmpty:
		*s = ProxyHostFingerprintEmpty
	case ProxyHostFingerprintChrome:
		*s = ProxyHostFingerprintChrome
	case ProxyHostFingerprintFirefox:
		*s = ProxyHostFingerprintFirefox
	case ProxyHostFingerprintSafari:
		*s = ProxyHostFingerprintSafari
	case ProxyHostFingerprintIos:
		*s = ProxyHostFingerprintIos
	case ProxyHostFingerprintAndroid:
		*s = ProxyHostFingerprintAndroid
	case ProxyHostFingerprintEdge:
		*s = ProxyHostFingerprintEdge
	case ProxyHostFingerprint360:
		*s = ProxyHostFingerprint360
	case ProxyHostFingerprintQq:
		*s = ProxyHostFingerprintQq
	case ProxyHostFingerprintRandom:
		*s = ProxyHostFingerprintRandom
	case ProxyHostFingerprintRandomized:
		*s = ProxyHostFingerprintRandomized
	default:
		*s = ProxyHostFingerprint(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProxyHostFingerprint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProxyHostFingerprint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProxyHostSecurity as json.
func (s ProxyHostSecurity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProxyHostSecurity from json.
func (s *ProxyHostSecurity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProxyHostSecurity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProxyHostSecurity(v) {
	case ProxyHostSecurityInboundDefault:
		*s = ProxyHostSecurityInboundDefault
	case ProxyHostSecurityNone:
		*s = ProxyHostSecurityNone
	case ProxyHostSecurityTLS:
		*s = ProxyHostSecurityTLS
	default:
		*s = ProxyHostSecurity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProxyHostSecurity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProxyHostSecurity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProxyInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProxyInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("protocol")
		s.Protocol.Encode(e)
	}
	{
		e.FieldStart("network")
		e.Str(s.Network)
	}
	{
		e.FieldStart("tls")
		e.Str(s.TLS)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
}

var jsonFieldsNameOfProxyInbound = [5]string{
	0: "tag",
	1: "protocol",
	2: "network",
	3: "tls",
	4: "port",
}

// Decode decodes ProxyInbound from json.
func (s *ProxyInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProxyInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "protocol":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Network = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "tls":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TLS = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tls\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProxyInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProxyInbound) {
					name = jsonFieldsNameOfProxyInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProxyInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProxyInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProxySettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProxySettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfProxySettings = [0]string{}

// Decode decodes ProxySettings from json.
func (s *ProxySettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProxySettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ProxySettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProxySettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProxySettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProxyTypes as json.
func (s ProxyTypes) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProxyTypes from json.
func (s *ProxyTypes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProxyTypes to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProxyTypes(v) {
	case ProxyTypesVmess:
		*s = ProxyTypesVmess
	case ProxyTypesVless:
		*s = ProxyTypesVless
	case ProxyTypesTrojan:
		*s = ProxyTypesTrojan
	case ProxyTypesShadowsocks:
		*s = ProxyTypesShadowsocks
	default:
		*s = ProxyTypes(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProxyTypes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProxyTypes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReconnectNodeOKApplicationJSON as json.
func (s ReconnectNodeOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes ReconnectNodeOKApplicationJSON from json.
func (s *ReconnectNodeOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReconnectNodeOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReconnectNodeOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReconnectNodeOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReconnectNodeOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveAdminOKApplicationJSON as json.
func (s RemoveAdminOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes RemoveAdminOKApplicationJSON from json.
func (s *RemoveAdminOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveAdminOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveAdminOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemoveAdminOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveAdminOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveNodeOKApplicationJSON as json.
func (s RemoveNodeOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes RemoveNodeOKApplicationJSON from json.
func (s *RemoveNodeOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveNodeOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveNodeOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemoveNodeOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveNodeOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveUserOKApplicationJSON as json.
func (s RemoveUserOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes RemoveUserOKApplicationJSON from json.
func (s *RemoveUserOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveUserOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveUserOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemoveUserOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveUserOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemoveUserTemplateOKApplicationJSON as json.
func (s RemoveUserTemplateOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes RemoveUserTemplateOKApplicationJSON from json.
func (s *RemoveUserTemplateOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveUserTemplateOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RemoveUserTemplateOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemoveUserTemplateOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveUserTemplateOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResetUsersDataUsageOKApplicationJSON as json.
func (s ResetUsersDataUsageOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes ResetUsersDataUsageOKApplicationJSON from json.
func (s *ResetUsersDataUsageOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUsersDataUsageOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ResetUsersDataUsageOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResetUsersDataUsageOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUsersDataUsageOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RestartCoreOKApplicationJSON as json.
func (s RestartCoreOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes RestartCoreOKApplicationJSON from json.
func (s *RestartCoreOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestartCoreOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RestartCoreOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RestartCoreOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestartCoreOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionUserResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionUserResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("proxies")
		s.Proxies.Encode(e)
	}
	{
		if s.Expire.Set {
			e.FieldStart("expire")
			s.Expire.Encode(e)
		}
	}
	{
		if s.DataLimit.Set {
			e.FieldStart("data_limit")
			s.DataLimit.Encode(e)
		}
	}
	{
		if s.DataLimitResetStrategy.Set {
			e.FieldStart("data_limit_reset_strategy")
			s.DataLimitResetStrategy.Encode(e)
		}
	}
	{
		if s.SubUpdatedAt.Set {
			e.FieldStart("sub_updated_at")
			s.SubUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.SubLastUserAgent.Set {
			e.FieldStart("sub_last_user_agent")
			s.SubLastUserAgent.Encode(e)
		}
	}
	{
		if s.OnlineAt.Set {
			e.FieldStart("online_at")
			s.OnlineAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.OnHoldExpireDuration.Set {
			e.FieldStart("on_hold_expire_duration")
			s.OnHoldExpireDuration.Encode(e)
		}
	}
	{
		if s.OnHoldTimeout.Set {
			e.FieldStart("on_hold_timeout")
			s.OnHoldTimeout.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.NextPlan.Set {
			e.FieldStart("next_plan")
			s.NextPlan.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("used_traffic")
		e.Int(s.UsedTraffic)
	}
	{
		if s.LifetimeUsedTraffic.Set {
			e.FieldStart("lifetime_used_traffic")
			s.LifetimeUsedTraffic.Encode(e)
		}
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		if s.Links != nil {
			e.FieldStart("links")
			e.ArrStart()
			for _, elem := range s.Links {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SubscriptionURL.Set {
			e.FieldStart("subscription_url")
			s.SubscriptionURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionUserResponse = [17]string{
	0:  "proxies",
	1:  "expire",
	2:  "data_limit",
	3:  "data_limit_reset_strategy",
	4:  "sub_updated_at",
	5:  "sub_last_user_agent",
	6:  "online_at",
	7:  "on_hold_expire_duration",
	8:  "on_hold_timeout",
	9:  "next_plan",
	10: "username",
	11: "status",
	12: "used_traffic",
	13: "lifetime_used_traffic",
	14: "created_at",
	15: "links",
	16: "subscription_url",
}

// Decode decodes SubscriptionUserResponse from json.
func (s *SubscriptionUserResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionUserResponse to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "proxies":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Proxies.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proxies\"")
			}
		case "expire":
			if err := func() error {
				s.Expire.Reset()
				if err := s.Expire.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expire\"")
			}
		case "data_limit":
			if err := func() error {
				s.DataLimit.Reset()
				if err := s.DataLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_limit\"")
			}
		case "data_limit_reset_strategy":
			if err := func() error {
				s.DataLimitResetStrategy.Reset()
				if err := s.DataLimitResetStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_limit_reset_strategy\"")
			}
		case "sub_updated_at":
			if err := func() error {
				s.SubUpdatedAt.Reset()
				if err := s.SubUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sub_updated_at\"")
			}
		case "sub_last_user_agent":
			if err := func() error {
				s.SubLastUserAgent.Reset()
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sub_last_user_agent\"")
			}
		case "online_at":
			if err := func() error {
				s.OnlineAt.Reset()
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"online_at\"")
			}
		case "on_hold_expire_duration":
			if err := func() error {
				s.OnHoldExpireDuration.Reset()
				if err := s.OnHoldExpireDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"on_hold_expire_duration\"")
			}
		case "on_hold_timeout":
			if err := func() error {
				s.OnHoldTimeout.Reset()
				if err := s.OnHoldTimeout.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"on_hold_timeout\"")
			}
		case "next_plan":
			if err := func() error {
				s.NextPlan.Reset()
				if err := s.NextPlan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_plan\"")
			}
		case "username":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "used_traffic":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.UsedTraffic = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used_traffic\"")
			}
		case "lifetime_used_traffic":
			if err := func() error {
				s.LifetimeUsedTraffic.Reset()
				if err := s.LifetimeUsedTraffic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetime_used_traffic\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "links":
			if err := func() error {
				s.Links = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Links = append(s.Links, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "subscription_url":
			if err := func() error {
				s.SubscriptionURL.Reset()
				if err := s.SubscriptionURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionUserResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b01011100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubscriptionUserResponse) {
					name = jsonFieldsNameOfSubscriptionUserResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionUserResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionUserResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionUserResponseProxies) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionUserResponseProxies) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSubscriptionUserResponseProxies = [0]string{}

// Decode decodes SubscriptionUserResponseProxies from json.
func (s *SubscriptionUserResponseProxies) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionUserResponseProxies to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionUserResponseProxies")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionUserResponseProxies) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionUserResponseProxies) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("mem_total")
		e.Int(s.MemTotal)
	}
	{
		e.FieldStart("mem_used")
		e.Int(s.MemUsed)
	}
	{
		e.FieldStart("cpu_cores")
		e.Int(s.CPUCores)
	}
	{
		e.FieldStart("cpu_usage")
		e.Float64(s.CPUUsage)
	}
	{
		e.FieldStart("total_user")
		e.Int(s.TotalUser)
	}
	{
		e.FieldStart("online_users")
		e.Int(s.OnlineUsers)
	}
	{
		e.FieldStart("users_active")
		e.Int(s.UsersActive)
	}
	{
		e.FieldStart("users_on_hold")
		e.Int(s.UsersOnHold)
	}
	{
		e.FieldStart("users_disabled")
		e.Int(s.UsersDisabled)
	}
	{
		e.FieldStart("users_expired")
		e.Int(s.UsersExpired)
	}
	{
		e.FieldStart("users_limited")
		e.Int(s.UsersLimited)
	}
	{
		e.FieldStart("incoming_bandwidth")
		e.Int(s.IncomingBandwidth)
	}
	{
		e.FieldStart("outgoing_bandwidth")
		e.Int(s.OutgoingBandwidth)
	}
	{
		e.FieldStart("incoming_bandwidth_speed")
		e.Int(s.IncomingBandwidthSpeed)
	}
	{
		e.FieldStart("outgoing_bandwidth_speed")
		e.Int(s.OutgoingBandwidthSpeed)
	}
}

var jsonFieldsNameOfSystemStats = [16]string{
	0:  "version",
	1:  "mem_total",
	2:  "mem_used",
	3:  "cpu_cores",
	4:  "cpu_usage",
	5:  "total_user",
	6:  "online_users",
	7:  "users_active",
	8:  "users_on_hold",
	9:  "users_disabled",
	10: "users_expired",
	11: "users_limited",
	12: "incoming_bandwidth",
	13: "outgoing_bandwidth",
	14: "incoming_bandwidth_speed",
	15: "outgoing_bandwidth_speed",
}

// Decode decodes SystemStats from json.
func (s *SystemStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemStats to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "mem_total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MemTotal = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mem_total\"")
			}
		case "mem_used":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MemUsed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mem_used\"")
			}
		case "cpu_cores":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CPUCores = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpu_cores\"")
			}
		case "cpu_usage":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.CPUUsage = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpu_usage\"")
			}
		case "total_user":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.TotalUser = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_user\"")
			}
		case "online_users":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.OnlineUsers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"online_users\"")
			}
		case "users_active":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.UsersActive = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users_active\"")
			}
		case "users_on_hold":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.UsersOnHold = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users_on_hold\"")
			}
		case "users_disabled":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.UsersDisabled = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users_disabled\"")
			}
		case "users_expired":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.UsersExpired = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users_expired\"")
			}
		case "users_limited":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.UsersLimited = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users_limited\"")
			}
		case "incoming_bandwidth":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.IncomingBandwidth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incoming_bandwidth\"")
			}
		case "outgoing_bandwidth":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.OutgoingBandwidth = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outgoing_bandwidth\"")
			}
		case "incoming_bandwidth_speed":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.IncomingBandwidthSpeed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incoming_bandwidth_speed\"")
			}
		case "outgoing_bandwidth_speed":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.OutgoingBandwidthSpeed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outgoing_bandwidth_speed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSystemStats) {
					name = jsonFieldsNameOfSystemStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Token) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Token) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_token")
		e.Str(s.AccessToken)
	}
	{
		if s.TokenType.Set {
			e.FieldStart("token_type")
			s.TokenType.Encode(e)
		}
	}
}

var jsonFieldsNameOfToken = [2]string{
	0: "access_token",
	1: "token_type",
}

// Decode decodes Token from json.
func (s *Token) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Token to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_token\"")
			}
		case "token_type":
			if err := func() error {
				s.TokenType.Reset()
				if err := s.TokenType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Token")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfToken) {
					name = jsonFieldsNameOfToken[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Token) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Token) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Unauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Unauthorized) encodeFields(e *jx.Encoder) {
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnauthorized = [1]string{
	0: "detail",
}

// Decode decodes Unauthorized from json.
func (s *Unauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Unauthorized to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Unauthorized")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Unauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Unauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserCreate) encodeFields(e *jx.Encoder) {
	{
		if s.Proxies.Set {
			e.FieldStart("proxies")
			s.Proxies.Encode(e)
		}
	}
	{
		if s.Expire.Set {
			e.FieldStart("expire")
			s.Expire.Encode(e)
		}
	}
	{
		if s.DataLimit.Set {
			e.FieldStart("data_limit")
			s.DataLimit.Encode(e)
		}
	}
	{
		if s.DataLimitResetStrategy.Set {
			e.FieldStart("data_limit_reset_strategy")
			s.DataLimitResetStrategy.Encode(e)
		}
	}
	{
		if s.Inbounds.Set {
			e.FieldStart("inbounds")
			s.Inbounds.Encode(e)
		}
	}
	{
		if s.Note.Set {
			e.FieldStart("note")
			s.Note.Encode(e)
		}
	}
	{
		if s.SubUpdatedAt.Set {
			e.FieldStart("sub_updated_at")
			s.SubUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.SubLastUserAgent.Set {
			e.FieldStart("sub_last_user_agent")
			s.SubLastUserAgent.Encode(e)
		}
	}
	{
		if s.OnlineAt.Set {
			e.FieldStart("online_at")
			s.OnlineAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.OnHoldExpireDuration.Set {
			e.FieldStart("on_hold_expire_duration")
			s.OnHoldExpireDuration.Encode(e)
		}
	}
	{
		if s.OnHoldTimeout.Set {
			e.FieldStart("on_hold_timeout")
			s.OnHoldTimeout.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.AutoDeleteInDays.Set {
			e.FieldStart("auto_delete_in_days")
			s.AutoDeleteInDays.Encode(e)
		}
	}
	{
		if s.NextPlan.Set {
			e.FieldStart("next_plan")
			s.NextPlan.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserCreate = [15]string{
	0:  "proxies",
	1:  "expire",
	2:  "data_limit",
	3:  "data_limit_reset_strategy",
	4:  "inbounds",
	5:  "note",
	6:  "sub_updated_at",
	7:  "sub_last_user_agent",
	8:  "online_at",
	9:  "on_hold_expire_duration",
	10: "on_hold_timeout",
	11: "auto_delete_in_days",
	12: "next_plan",
	13: "username",
	14: "status",
}

// Decode decodes UserCreate from json.
func (s *UserCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserCreate to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "proxies":
			if err := func() error {
				s.Proxies.Reset()
				if err := s.Proxies.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proxies\"")
			}
		case "expire":
			if err := func() error {
				s.Expire.Reset()
				if err := s.Expire.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expire\"")
			}
		case "data_limit":
			if err := func() error {
				s.DataLimit.Reset()
				if err := s.DataLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_limit\"")
			}
		case "data_limit_reset_strategy":
			if err := func() error {
				s.DataLimitResetStrategy.Reset()
				if err := s.DataLimitResetStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_limit_reset_strategy\"")
			}
		case "inbounds":
			if err := func() error {
				s.Inbounds.Reset()
				if err := s.Inbounds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "sub_updated_at":
			if err := func() error {
				s.SubUpdatedAt.Reset()
				if err := s.SubUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sub_updated_at\"")
			}
		case "sub_last_user_agent":
			if err := func() error {
				s.SubLastUserAgent.Reset()
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sub_last_user_agent\"")
			}
		case "online_at":
			if err := func() error {
				s.OnlineAt.Reset()
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"online_at\"")
			}
		case "on_hold_expire_duration":
			if err := func() error {
				s.OnHoldExpireDuration.Reset()
				if err := s.OnHoldExpireDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"on_hold_expire_duration\"")
			}
		case "on_hold_timeout":
			if err := func() error {
				s.OnHoldTimeout.Reset()
				if err := s.OnHoldTimeout.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"on_hold_timeout\"")
			}
		case "auto_delete_in_days":
			if err := func() error {
				s.AutoDeleteInDays.Reset()
				if err := s.AutoDeleteInDays.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_delete_in_days\"")
			}
		case "next_plan":
			if err := func() error {
				s.NextPlan.Reset()
				if err := s.NextPlan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_plan\"")
			}
		case "username":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000000,
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserCreate) {
					name = jsonFieldsNameOfUserCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UserCreateInbounds) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UserCreateInbounds) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes UserCreateInbounds from json.
func (s *UserCreateInbounds) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserCreateInbounds to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []string
		if err := func() error {
			elem = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem string
				v, err := d.Str()
				elemElem = string(v)
				if err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserCreateInbounds")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserCreateInbounds) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserCreateInbounds) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UserCreateProxies) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UserCreateProxies) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes UserCreateProxies from json.
func (s *UserCreateProxies) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserCreateProxies to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem ProxySettings
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserCreateProxies")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserCreateProxies) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserCreateProxies) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserDataLimitResetStrategy as json.
func (s UserDataLimitResetStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserDataLimitResetStrategy from json.
func (s *UserDataLimitResetStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserDataLimitResetStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserDataLimitResetStrategy(v) {
	case UserDataLimitResetStrategyNoReset:
		*s = UserDataLimitResetStrategyNoReset
	case UserDataLimitResetStrategyDay:
		*s = UserDataLimitResetStrategyDay
	case UserDataLimitResetStrategyWeek:
		*s = UserDataLimitResetStrategyWeek
	case UserDataLimitResetStrategyMonth:
		*s = UserDataLimitResetStrategyMonth
	case UserDataLimitResetStrategyYear:
		*s = UserDataLimitResetStrategyYear
	default:
		*s = UserDataLimitResetStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserDataLimitResetStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserDataLimitResetStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserGetUsageOKApplicationJSON as json.
func (s UserGetUsageOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes UserGetUsageOKApplicationJSON from json.
func (s *UserGetUsageOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserGetUsageOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UserGetUsageOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserGetUsageOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserGetUsageOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserModify) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserModify) encodeFields(e *jx.Encoder) {
	{
		if s.Proxies.Set {
			e.FieldStart("proxies")
			s.Proxies.Encode(e)
		}
	}
	{
		if s.Expire.Set {
			e.FieldStart("expire")
			s.Expire.Encode(e)
		}
	}
	{
		if s.DataLimit.Set {
			e.FieldStart("data_limit")
			s.DataLimit.Encode(e)
		}
	}
	{
		if s.DataLimitResetStrategy.Set {
			e.FieldStart("data_limit_reset_strategy")
			s.DataLimitResetStrategy.Encode(e)
		}
	}
	{
		if s.Inbounds.Set {
			e.FieldStart("inbounds")
			s.Inbounds.Encode(e)
		}
	}
	{
		if s.Note.Set {
			e.FieldStart("note")
			s.Note.Encode(e)
		}
	}
	{
		if s.SubUpdatedAt.Set {
			e.FieldStart("sub_updated_at")
			s.SubUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.SubLastUserAgent.Set {
			e.FieldStart("sub_last_user_agent")
			s.SubLastUserAgent.Encode(e)
		}
	}
	{
		if s.OnlineAt.Set {
			e.FieldStart("online_at")
			s.OnlineAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.OnHoldExpireDuration.Set {
			e.FieldStart("on_hold_expire_duration")
			s.OnHoldExpireDuration.Encode(e)
		}
	}
	{
		if s.OnHoldTimeout.Set {
			e.FieldStart("on_hold_timeout")
			s.OnHoldTimeout.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.AutoDeleteInDays.Set {
			e.FieldStart("auto_delete_in_days")
			s.AutoDeleteInDays.Encode(e)
		}
	}
	{
		if s.NextPlan.Set {
			e.FieldStart("next_plan")
			s.NextPlan.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserModify = [14]string{
	0:  "proxies",
	1:  "expire",
	2:  "data_limit",
	3:  "data_limit_reset_strategy",
	4:  "inbounds",
	5:  "note",
	6:  "sub_updated_at",
	7:  "sub_last_user_agent",
	8:  "online_at",
	9:  "on_hold_expire_duration",
	10: "on_hold_timeout",
	11: "auto_delete_in_days",
	12: "next_plan",
	13: "status",
}

// Decode decodes UserModify from json.
func (s *UserModify) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserModify to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "proxies":
			if err := func() error {
				s.Proxies.Reset()
				if err := s.Proxies.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proxies\"")
			}
		case "expire":
			if err := func() error {
				s.Expire.Reset()
				if err := s.Expire.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expire\"")
			}
		case "data_limit":
			if err := func() error {
				s.DataLimit.Reset()
				if err := s.DataLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_limit\"")
			}
		case "data_limit_reset_strategy":
			if err := func() error {
				s.DataLimitResetStrategy.Reset()
				if err := s.DataLimitResetStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_limit_reset_strategy\"")
			}
		case "inbounds":
			if err := func() error {
				s.Inbounds.Reset()
				if err := s.Inbounds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "sub_updated_at":
			if err := func() error {
				s.SubUpdatedAt.Reset()
				if err := s.SubUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sub_updated_at\"")
			}
		case "sub_last_user_agent":
			if err := func() error {
				s.SubLastUserAgent.Reset()
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sub_last_user_agent\"")
			}
		case "online_at":
			if err := func() error {
				s.OnlineAt.Reset()
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"online_at\"")
			}
		case "on_hold_expire_duration":
			if err := func() error {
				s.OnHoldExpireDuration.Reset()
				if err := s.OnHoldExpireDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"on_hold_expire_duration\"")
			}
		case "on_hold_timeout":
			if err := func() error {
				s.OnHoldTimeout.Reset()
				if err := s.OnHoldTimeout.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"on_hold_timeout\"")
			}
		case "auto_delete_in_days":
			if err := func() error {
				s.AutoDeleteInDays.Reset()
				if err := s.AutoDeleteInDays.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_delete_in_days\"")
			}
		case "next_plan":
			if err := func() error {
				s.NextPlan.Reset()
				if err := s.NextPlan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_plan\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserModify")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserModify) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserModify) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UserModifyInbounds) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UserModifyInbounds) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes UserModifyInbounds from json.
func (s *UserModifyInbounds) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserModifyInbounds to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []string
		if err := func() error {
			elem = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem string
				v, err := d.Str()
				elemElem = string(v)
				if err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserModifyInbounds")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserModifyInbounds) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserModifyInbounds) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UserModifyProxies) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UserModifyProxies) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes UserModifyProxies from json.
func (s *UserModifyProxies) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserModifyProxies to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem ProxySettings
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserModifyProxies")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserModifyProxies) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserModifyProxies) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("proxies")
		s.Proxies.Encode(e)
	}
	{
		if s.Expire.Set {
			e.FieldStart("expire")
			s.Expire.Encode(e)
		}
	}
	{
		if s.DataLimit.Set {
			e.FieldStart("data_limit")
			s.DataLimit.Encode(e)
		}
	}
	{
		if s.DataLimitResetStrategy.Set {
			e.FieldStart("data_limit_reset_strategy")
			s.DataLimitResetStrategy.Encode(e)
		}
	}
	{
		if s.Inbounds.Set {
			e.FieldStart("inbounds")
			s.Inbounds.Encode(e)
		}
	}
	{
		if s.Note.Set {
			e.FieldStart("note")
			s.Note.Encode(e)
		}
	}
	{
		if s.SubUpdatedAt.Set {
			e.FieldStart("sub_updated_at")
			s.SubUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.SubLastUserAgent.Set {
			e.FieldStart("sub_last_user_agent")
			s.SubLastUserAgent.Encode(e)
		}
	}
	{
		if s.OnlineAt.Set {
			e.FieldStart("online_at")
			s.OnlineAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.OnHoldExpireDuration.Set {
			e.FieldStart("on_hold_expire_duration")
			s.OnHoldExpireDuration.Encode(e)
		}
	}
	{
		if s.OnHoldTimeout.Set {
			e.FieldStart("on_hold_timeout")
			s.OnHoldTimeout.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.AutoDeleteInDays.Set {
			e.FieldStart("auto_delete_in_days")
			s.AutoDeleteInDays.Encode(e)
		}
	}
	{
		if s.NextPlan.Set {
			e.FieldStart("next_plan")
			s.NextPlan.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("used_traffic")
		e.Int(s.UsedTraffic)
	}
	{
		if s.LifetimeUsedTraffic.Set {
			e.FieldStart("lifetime_used_traffic")
			s.LifetimeUsedTraffic.Encode(e)
		}
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		if s.Links != nil {
			e.FieldStart("links")
			e.ArrStart()
			for _, elem := range s.Links {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SubscriptionURL.Set {
			e.FieldStart("subscription_url")
			s.SubscriptionURL.Encode(e)
		}
	}
	{
		if s.ExcludedInbounds.Set {
			e.FieldStart("excluded_inbounds")
			s.ExcludedInbounds.Encode(e)
		}
	}
	{
		if s.Admin.Set {
			e.FieldStart("admin")
			s.Admin.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserResponse = [22]string{
	0:  "proxies",
	1:  "expire",
	2:  "data_limit",
	3:  "data_limit_reset_strategy",
	4:  "inbounds",
	5:  "note",
	6:  "sub_updated_at",
	7:  "sub_last_user_agent",
	8:  "online_at",
	9:  "on_hold_expire_duration",
	10: "on_hold_timeout",
	11: "auto_delete_in_days",
	12: "next_plan",
	13: "username",
	14: "status",
	15: "used_traffic",
	16: "lifetime_used_traffic",
	17: "created_at",
	18: "links",
	19: "subscription_url",
	20: "excluded_inbounds",
	21: "admin",
}

// Decode decodes UserResponse from json.
func (s *UserResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserResponse to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "proxies":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Proxies.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"proxies\"")
			}
		case "expire":
			if err := func() error {
				s.Expire.Reset()
				if err := s.Expire.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expire\"")
			}
		case "data_limit":
			if err := func() error {
				s.DataLimit.Reset()
				if err := s.DataLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_limit\"")
			}
		case "data_limit_reset_strategy":
			if err := func() error {
				s.DataLimitResetStrategy.Reset()
				if err := s.DataLimitResetStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_limit_reset_strategy\"")
			}
		case "inbounds":
			if err := func() error {
				s.Inbounds.Reset()
				if err := s.Inbounds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "sub_updated_at":
			if err := func() error {
				s.SubUpdatedAt.Reset()
				if err := s.SubUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sub_updated_at\"")
			}
		case "sub_last_user_agent":
			if err := func() error {
				s.SubLastUserAgent.Reset()
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sub_last_user_agent\"")
			}
		case "online_at":
			if err := func() error {
				s.OnlineAt.Reset()
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"online_at\"")
			}
		case "on_hold_expire_duration":
			if err := func() error {
				s.OnHoldExpireDuration.Reset()
				if err := s.OnHoldExpireDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"on_hold_expire_duration\"")
			}
		case "on_hold_timeout":
			if err := func() error {
				s.OnHoldTimeout.Reset()
				if err := s.OnHoldTimeout.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"on_hold_timeout\"")
			}
		case "auto_delete_in_days":
			if err := func() error {
				s.AutoDeleteInDays.Reset()
				if err := s.AutoDeleteInDays.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_delete_in_days\"")
			}
		case "next_plan":
			if err := func() error {
				s.NextPlan.Reset()
				if err := s.NextPlan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_plan\"")
			}
		case "username":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "used_traffic":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.UsedTraffic = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used_traffic\"")
			}
		case "lifetime_used_traffic":
			if err := func() error {
				s.LifetimeUsedTraffic.Reset()
				if err := s.LifetimeUsedTraffic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetime_used_traffic\"")
			}
		case "created_at":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "links":
			if err := func() error {
				s.Links = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Links = append(s.Links, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "subscription_url":
			if err := func() error {
				s.SubscriptionURL.Reset()
				if err := s.SubscriptionURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription_url\"")
			}
		case "excluded_inbounds":
			if err := func() error {
				s.ExcludedInbounds.Reset()
				if err := s.ExcludedInbounds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"excluded_inbounds\"")
			}
		case "admin":
			if err := func() error {
				s.Admin.Reset()
				if err := s.Admin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b11100000,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserResponse) {
					name = jsonFieldsNameOfUserResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UserResponseExcludedInbounds) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UserResponseExcludedInbounds) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes UserResponseExcludedInbounds from json.
func (s *UserResponseExcludedInbounds) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserResponseExcludedInbounds to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []string
		if err := func() error {
			elem = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem string
				v, err := d.Str()
				elemElem = string(v)
				if err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserResponseExcludedInbounds")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserResponseExcludedInbounds) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserResponseExcludedInbounds) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UserResponseInbounds) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UserResponseInbounds) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes UserResponseInbounds from json.
func (s *UserResponseInbounds) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserResponseInbounds to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []string
		if err := func() error {
			elem = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem string
				v, err := d.Str()
				elemElem = string(v)
				if err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserResponseInbounds")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserResponseInbounds) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserResponseInbounds) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserResponseProxies) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserResponseProxies) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUserResponseProxies = [0]string{}

// Decode decodes UserResponseProxies from json.
func (s *UserResponseProxies) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserResponseProxies to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UserResponseProxies")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserResponseProxies) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserResponseProxies) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserStatus as json.
func (s UserStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserStatus from json.
func (s *UserStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserStatus(v) {
	case UserStatusActive:
		*s = UserStatusActive
	case UserStatusDisabled:
		*s = UserStatusDisabled
	case UserStatusLimited:
		*s = UserStatusLimited
	case UserStatusExpired:
		*s = UserStatusExpired
	case UserStatusOnHold:
		*s = UserStatusOnHold
	default:
		*s = UserStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserStatusCreate as json.
func (s UserStatusCreate) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserStatusCreate from json.
func (s *UserStatusCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserStatusCreate to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserStatusCreate(v) {
	case UserStatusCreateActive:
		*s = UserStatusCreateActive
	case UserStatusCreateOnHold:
		*s = UserStatusCreateOnHold
	default:
		*s = UserStatusCreate(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserStatusCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserStatusCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserStatusModify as json.
func (s UserStatusModify) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserStatusModify from json.
func (s *UserStatusModify) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserStatusModify to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserStatusModify(v) {
	case UserStatusModifyActive:
		*s = UserStatusModifyActive
	case UserStatusModifyDisabled:
		*s = UserStatusModifyDisabled
	case UserStatusModifyOnHold:
		*s = UserStatusModifyOnHold
	default:
		*s = UserStatusModify(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserStatusModify) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserStatusModify) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserSubscriptionOKApplicationJSON as json.
func (s UserSubscriptionOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes UserSubscriptionOKApplicationJSON from json.
func (s *UserSubscriptionOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserSubscriptionOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UserSubscriptionOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserSubscriptionOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserSubscriptionOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserSubscriptionWithClientTypeOKApplicationJSON as json.
func (s UserSubscriptionWithClientTypeOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes UserSubscriptionWithClientTypeOKApplicationJSON from json.
func (s *UserSubscriptionWithClientTypeOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserSubscriptionWithClientTypeOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UserSubscriptionWithClientTypeOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserSubscriptionWithClientTypeOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserSubscriptionWithClientTypeOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserTemplateCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserTemplateCreate) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.DataLimit.Set {
			e.FieldStart("data_limit")
			s.DataLimit.Encode(e)
		}
	}
	{
		if s.ExpireDuration.Set {
			e.FieldStart("expire_duration")
			s.ExpireDuration.Encode(e)
		}
	}
	{
		if s.UsernamePrefix.Set {
			e.FieldStart("username_prefix")
			s.UsernamePrefix.Encode(e)
		}
	}
	{
		if s.UsernameSuffix.Set {
			e.FieldStart("username_suffix")
			s.UsernameSuffix.Encode(e)
		}
	}
	{
		if s.Inbounds.Set {
			e.FieldStart("inbounds")
			s.Inbounds.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserTemplateCreate = [6]string{
	0: "name",
	1: "data_limit",
	2: "expire_duration",
	3: "username_prefix",
	4: "username_suffix",
	5: "inbounds",
}

// Decode decodes UserTemplateCreate from json.
func (s *UserTemplateCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserTemplateCreate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "data_limit":
			if err := func() error {
				s.DataLimit.Reset()
				if err := s.DataLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_limit\"")
			}
		case "expire_duration":
			if err := func() error {
				s.ExpireDuration.Reset()
				if err := s.ExpireDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expire_duration\"")
			}
		case "username_prefix":
			if err := func() error {
				s.UsernamePrefix.Reset()
				if err := s.UsernamePrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username_prefix\"")
			}
		case "username_suffix":
			if err := func() error {
				s.UsernameSuffix.Reset()
				if err := s.UsernameSuffix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username_suffix\"")
			}
		case "inbounds":
			if err := func() error {
				s.Inbounds.Reset()
				if err := s.Inbounds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserTemplateCreate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserTemplateCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserTemplateCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UserTemplateCreateInbounds) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UserTemplateCreateInbounds) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes UserTemplateCreateInbounds from json.
func (s *UserTemplateCreateInbounds) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserTemplateCreateInbounds to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []string
		if err := func() error {
			elem = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem string
				v, err := d.Str()
				elemElem = string(v)
				if err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserTemplateCreateInbounds")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserTemplateCreateInbounds) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserTemplateCreateInbounds) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserTemplateModify) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserTemplateModify) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.DataLimit.Set {
			e.FieldStart("data_limit")
			s.DataLimit.Encode(e)
		}
	}
	{
		if s.ExpireDuration.Set {
			e.FieldStart("expire_duration")
			s.ExpireDuration.Encode(e)
		}
	}
	{
		if s.UsernamePrefix.Set {
			e.FieldStart("username_prefix")
			s.UsernamePrefix.Encode(e)
		}
	}
	{
		if s.UsernameSuffix.Set {
			e.FieldStart("username_suffix")
			s.UsernameSuffix.Encode(e)
		}
	}
	{
		if s.Inbounds.Set {
			e.FieldStart("inbounds")
			s.Inbounds.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserTemplateModify = [6]string{
	0: "name",
	1: "data_limit",
	2: "expire_duration",
	3: "username_prefix",
	4: "username_suffix",
	5: "inbounds",
}

// Decode decodes UserTemplateModify from json.
func (s *UserTemplateModify) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserTemplateModify to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "data_limit":
			if err := func() error {
				s.DataLimit.Reset()
				if err := s.DataLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_limit\"")
			}
		case "expire_duration":
			if err := func() error {
				s.ExpireDuration.Reset()
				if err := s.ExpireDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expire_duration\"")
			}
		case "username_prefix":
			if err := func() error {
				s.UsernamePrefix.Reset()
				if err := s.UsernamePrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username_prefix\"")
			}
		case "username_suffix":
			if err := func() error {
				s.UsernameSuffix.Reset()
				if err := s.UsernameSuffix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username_suffix\"")
			}
		case "inbounds":
			if err := func() error {
				s.Inbounds.Reset()
				if err := s.Inbounds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserTemplateModify")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserTemplateModify) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserTemplateModify) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UserTemplateModifyInbounds) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UserTemplateModifyInbounds) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes UserTemplateModifyInbounds from json.
func (s *UserTemplateModifyInbounds) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserTemplateModifyInbounds to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []string
		if err := func() error {
			elem = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem string
				v, err := d.Str()
				elemElem = string(v)
				if err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserTemplateModifyInbounds")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserTemplateModifyInbounds) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserTemplateModifyInbounds) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserTemplateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserTemplateResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.DataLimit.Set {
			e.FieldStart("data_limit")
			s.DataLimit.Encode(e)
		}
	}
	{
		if s.ExpireDuration.Set {
			e.FieldStart("expire_duration")
			s.ExpireDuration.Encode(e)
		}
	}
	{
		if s.UsernamePrefix.Set {
			e.FieldStart("username_prefix")
			s.UsernamePrefix.Encode(e)
		}
	}
	{
		if s.UsernameSuffix.Set {
			e.FieldStart("username_suffix")
			s.UsernameSuffix.Encode(e)
		}
	}
	{
		if s.Inbounds.Set {
			e.FieldStart("inbounds")
			s.Inbounds.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Int(s.ID)
	}
}

var jsonFieldsNameOfUserTemplateResponse = [7]string{
	0: "name",
	1: "data_limit",
	2: "expire_duration",
	3: "username_prefix",
	4: "username_suffix",
	5: "inbounds",
	6: "id",
}

// Decode decodes UserTemplateResponse from json.
func (s *UserTemplateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserTemplateResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "data_limit":
			if err := func() error {
				s.DataLimit.Reset()
				if err := s.DataLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_limit\"")
			}
		case "expire_duration":
			if err := func() error {
				s.ExpireDuration.Reset()
				if err := s.ExpireDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expire_duration\"")
			}
		case "username_prefix":
			if err := func() error {
				s.UsernamePrefix.Reset()
				if err := s.UsernamePrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username_prefix\"")
			}
		case "username_suffix":
			if err := func() error {
				s.UsernameSuffix.Reset()
				if err := s.UsernameSuffix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username_suffix\"")
			}
		case "inbounds":
			if err := func() error {
				s.Inbounds.Reset()
				if err := s.Inbounds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserTemplateResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserTemplateResponse) {
					name = jsonFieldsNameOfUserTemplateResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserTemplateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserTemplateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UserTemplateResponseInbounds) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UserTemplateResponseInbounds) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes UserTemplateResponseInbounds from json.
func (s *UserTemplateResponseInbounds) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserTemplateResponseInbounds to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []string
		if err := func() error {
			elem = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem string
				v, err := d.Str()
				elemElem = string(v)
				if err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserTemplateResponseInbounds")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserTemplateResponseInbounds) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserTemplateResponseInbounds) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserUsageResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserUsageResponse) encodeFields(e *jx.Encoder) {
	{
		if s.NodeID.Set {
			e.FieldStart("node_id")
			s.NodeID.Encode(e)
		}
	}
	{
		e.FieldStart("node_name")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("used_traffic")
		e.Int(s.UsedTraffic)
	}
}

var jsonFieldsNameOfUserUsageResponse = [3]string{
	0: "node_id",
	1: "node_name",
	2: "used_traffic",
}

// Decode decodes UserUsageResponse from json.
func (s *UserUsageResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserUsageResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "node_id":
			if err := func() error {
				s.NodeID.Reset()
				if err := s.NodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "node_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_name\"")
			}
		case "used_traffic":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.UsedTraffic = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used_traffic\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserUsageResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserUsageResponse) {
					name = jsonFieldsNameOfUserUsageResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserUsageResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserUsageResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserUsagesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserUsagesResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("usages")
		e.ArrStart()
		for _, elem := range s.Usages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUserUsagesResponse = [2]string{
	0: "username",
	1: "usages",
}

// Decode decodes UserUsagesResponse from json.
func (s *UserUsagesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserUsagesResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "usages":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Usages = make([]UserUsageResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserUsageResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Usages = append(s.Usages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserUsagesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserUsagesResponse) {
					name = jsonFieldsNameOfUserUsagesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserUsagesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserUsagesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("users")
		e.ArrStart()
		for _, elem := range s.Users {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Int(s.Total)
	}
}

var jsonFieldsNameOfUsersResponse = [2]string{
	0: "users",
	1: "total",
}

// Decode decodes UsersResponse from json.
func (s *UsersResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Users = make([]UserResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Total = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUsersResponse) {
					name = jsonFieldsNameOfUsersResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersUsagesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersUsagesResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("usages")
		e.ArrStart()
		for _, elem := range s.Usages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUsersUsagesResponse = [1]string{
	0: "usages",
}

// Decode decodes UsersUsagesResponse from json.
func (s *UsersUsagesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersUsagesResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "usages":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Usages = make([]UserUsageResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserUsageResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Usages = append(s.Usages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersUsagesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUsersUsagesResponse) {
					name = jsonFieldsNameOfUsersUsagesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersUsagesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersUsagesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidationError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidationError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("loc")
		e.ArrStart()
		for _, elem := range s.Loc {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("msg")
		e.Str(s.Msg)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfValidationError = [3]string{
	0: "loc",
	1: "msg",
	2: "type",
}

// Decode decodes ValidationError from json.
func (s *ValidationError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "loc":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Loc = make([]NilString, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NilString
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Loc = append(s.Loc, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loc\"")
			}
		case "msg":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Msg = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"msg\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidationError) {
					name = jsonFieldsNameOfValidationError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
